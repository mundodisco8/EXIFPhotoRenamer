"""This module provides the RP Renamer main window."""

from collections import deque
from json import dump
from pathlib import Path
from typing import Any

from PySide6.QtWidgets import QWidget, QFileDialog, QDialog, QListWidgetItem
from PySide6.QtCore import Slot, QProcess, QObject, QRunnable, QThreadPool, Signal

from ui.mainWindow import Ui_MainWindow
from ui.mediaFileViewer import Ui_MediaFileViewer
from massRenamer.massRenamerClasses import (
    generateSortedMediaFileList,
    getFilesInFolder,
    loadExifToolTagsFromFile,
    tagsToExtract,
)


class WorkerSignals(QObject):
    """Signals from a running worker thread.

    started:
        emitted when a worker starts running

    finished
        emitted when a worked finishes running

    message
        tuple(str, LogRecord) emitted when something is printed by the logger, sends a formatted message ready to print
        and a copy of the LogRecord to extract the metadata needed to get the correct colour for that log level

    error
        tuple (exctype, value, traceback.format_exc()) can be emitted to trace exceptions

    result
        object data returned from the worker thread
    """

    started = Signal()
    finished = Signal()
    message = Signal()
    error = Signal(tuple)
    result = Signal(object)


class tagReaderWorker(QRunnable):
    """Worker Thread - Reads the tags from a folder using ExifTool

    Args:
        QRunnable (_type_): _description_
    """

    def __init__(self, dirName: Path, *args: Any, **kwargs: Any) -> None:
        """Init the class"""
        super().__init__()
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()
        self.dirName = dirName
        self._running = True

    @Slot()
    def run(self) -> None:
        """Your long-running job goes in this method."""
        cmdArgs: list[str | Path] = ["-time:all", "-G1", "-a", "-s", "-j", "-r", self.dirName]

        self.p = QProcess()
        self.signals.started.emit()
        self.p.readyReadStandardOutput.connect(self.handleStdOut)
        self.p.readyReadStandardError.connect(self.handleStdOut)
        self.p.stateChanged.connect(self.handleState)
        # p.readyReadStandardError.connect(self.handle_stderr)
        self.p.start("exiftool", [str(arg) for arg in cmdArgs])
        while self._running:
            # wait here for the process to end
            pass
        self.signals.finished.emit()  # Done

    @Slot()
    def handleStdOut(self) -> None:
        """Check the standard out for signs of files being processed and update the progress bar"""
        data = self.p.readAllStandardOutput().toStdString()
        for line in data.splitlines():
            #     line = p.stdout.readline()
            if line:
                line.rstrip()
                # jsonOut += line
                if "SourceFile" in line:
                    self.signals.message.emit()
        #             self.pushButton_3.setText(f"{filesProcessed}/{numFiles}")
        #             self.progressBar.setValue(filesProcessed)  # update the bar's progress

    @Slot()
    def handleState(self, state: QProcess.ProcessState) -> None:
        if state == QProcess.ProcessState.NotRunning:
            self._running = False

    def write(self, text: str):
        """Emits the message signal, so text generated by the worker can be logged"""
        self.signals.message.emit(text)


class Window(QWidget, Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self._setupUI()

        # This will hold the list of files to process
        self._files: deque[Path] = deque()
        self._filesCount = len(self._files)

        ### UI stuff
        self.mediaFileViewer = MediaFileViewer(self)
        self.openFolderBtn.clicked.connect(self.loadFolder)
        self.openJSONBtn.clicked.connect(self.loadJSON)
        self.mediaFileViewerBtn.clicked.connect(self.showMediaFileViewer)
        self.toRenameList.itemClicked.connect(self.updateMediaFileViewer)

        ### Threading stuff
        self.responderThread: tagReaderWorker | None = None
        self.threadpool = QThreadPool()

    def _setupUI(self):
        self.setupUi(self)

    @Slot()
    def processStarts(self) -> None:
        """_summary_"""
        self.toRenameList.addItem("Process Starts")

    @Slot()
    def processEnds(self) -> None:
        """_summary_"""
        self.toRenameList.addItem("Process Ends")

    @Slot()
    def updateProgressBar(self) -> None:
        """_summary_"""
        currVal = self.progressBar.value()
        self.progressBar.setValue(currVal + 1)

    @Slot()
    def loadFolder(self) -> None:
        """Action for the openFolderBtn clicked signal

        Opens a file dialog to allow picking the files to rename, stores them in self._files and prints their names
        in the Files to Rename list.
        """

        if self.responderThread:
            # A process is already running, do nothing
            return

        # Else, let's select a folder and process its files

        self.toRenameList.clear()  # clear the files to rename list on button click
        self.currJSONTxt.clear()  # clear the any current JSON
        # If the currDirTxt lineEdit has text on it, use it as reference for the file dialog. Otherwise, use home() as
        # starting point
        if self.currDirTxt.text():
            initDir = self.currDirTxt.text()
        else:
            # initDir = str(Path.home())  # default to the user's home
            initDir = r"C:\Users\mundo\OneDrive\Desktop\EXIFPhotoRenamer\FotosTest\A"

        self._selDir = QFileDialog.getExistingDirectory(self, "Choose Folder Containing the Files To Rename", initDir)

        # Get the number of files in the dir
        self.progressBarTxt.setText("Countnig processsable files in the folder...")
        self.repaint()  # need this to force the change in UI before we hit the UI in the event loop
        numFiles = getFilesInFolder(Path(self._selDir))
        self.progressBar.setFormat("Processed %v / %m...")
        self.progressBar.setRange(0, numFiles)
        self.progressBar.setValue(0)

        # Tags to Extract
        # The date formatting is super useful, as it's really smart grabbing offsets, I think
        # -a allow duplicate tags
        # -s short tag names (no effect with json output but I'll leave it)
        # -j output json
        # -r recursive folder search
        # -d "%Y-%m-%dT%H:%M:%S%:z" output dates in YYYY-MM-DDTHH:MM:SS+/-Offset
        cmdArgs: list[str] = tagsToExtract + ["-G1", "-a", "-s", "-j", "-r", "-d", "%Y-%m-%dT%H:%M:%S%:z", self._selDir]

        self.p = QProcess()
        self.processOutput: str = ""
        self.p.readyReadStandardOutput.connect(self.handleStdOut)
        self.p.readyReadStandardError.connect(self.handleStdOut)
        self.p.stateChanged.connect(self.handleState)
        self.progressBarTxt.setText("Extracting Tags from Files...")
        self.repaint()
        self.p.start("exiftool", cmdArgs)

    @Slot()
    def handleStdOut(self) -> None:
        """Check the standard out for signs of files being processed and update the progress bar"""
        data = self.p.readAllStandardOutput().toStdString()
        for line in data.splitlines():
            if line:
                line.rstrip()
                self.processOutput += line
                if "SourceFile" in line:
                    self.progressBar.setValue(self.progressBar.value() + 1)
                    self.repaint()

    @Slot()
    def handleState(self, state: QProcess.ProcessState) -> None:
        if state == QProcess.ProcessState.NotRunning:
            saveFile, _ = QFileDialog.getSaveFileName(
                self,
                "Select A File to Save the Tags",
                self._selDir + "/fileTags.json",  # add fileTags.json to suggest it as predetermined file name
                "JSON Files (*.json)",
            )

            # If the Dialog is cancelled, the file returned is ""
            if saveFile:
                with open(Path(saveFile), "w+") as writeFile:
                    writeFile.write(self.processOutput)
                self.progressBarTxt.setText(f"Tags Saved in {saveFile}")
            else:
                self.progressBarTxt.setText(f"We didn't save the tags :(")

    @Slot()
    def loadJSON(self) -> None:
        self.toRenameList.clear()
        # If the current directory field has something on it, use it as starting point for looking for a JSON
        if self.currDirTxt.text():
            initDir = self.currDirTxt.text()
        else:
            # initDir = str(Path.home())  # default to the user's home
            initDir = r"C:\Users\mundo\OneDrive\Desktop\EXIFPhotoRenamer\FotosTest\A"
        self._jsonFile, _ = QFileDialog.getOpenFileName(self, "Pick a JSON file with your EXIF tags", initDir, "*.json")
        self.currJSONTxt.setText(self._jsonFile)
        # Clear it after the JSON was selected, to avoid ambiguity about what is open
        self.currDirTxt.clear()

        # Load the JSON
        tagsDictList = loadExifToolTagsFromFile(Path(self._jsonFile))

        self.mediaFileList = generateSortedMediaFileList(tagsDictList)

        #  3) Store MediaFile list on disk
        # storeMediaFileList(objectFile, mediaList)
        # 4) Find Dateless, try to correct them by hand
        dateless = [instance for instance in self.mediaFileList if instance.dateTime is None]

        if len(dateless) > 0:
            for item in dateless:
                self.toRenameList.addItem(str(item.fileName))
        else:
            for item in self.mediaFileList:
                self.toRenameList.addItem(str(item.fileName))

    @Slot()
    def showMediaFileViewer(self) -> None:
        """Shows the MediaFile Viewer"""
        self.mediaFileViewer.show()
        # Reposition Window to the right of the main window on show.
        # X coord is MainWindow's x + MainWindow's width (so both windows match side to side)
        # Y coord is MainWindow's y (so titlebars are aligned in height)
        self.mediaFileViewer.move(self.geometry().x() + self.width(), self.y())

    @Slot(QListWidgetItem)
    def updateMediaFileViewer(self, current: QListWidgetItem) -> None:
        # self.mediaFileViewer.filePathTxt.setText(previous.text())
        # next((x for x in test_list if x.value == value), None)
        instance = None
        for instance in self.mediaFileList:
            if instance.fileName == Path(current.text()):
                break
            else:
                instance = None

        if instance:
            self.mediaFileViewer.filePathTxt.setText(str(instance.fileName))
            self.mediaFileViewer.dateTimeTxt.setText(instance.dateTime)
            self.mediaFileViewer.sidecarTxt.setText(str(instance.sidecar))
            self.mediaFileViewer.sourceTxt.setText(instance.source)


class MediaFileViewer(QDialog, Ui_MediaFileViewer):
    def __init__(self, parent: None | QWidget = None):
        super().__init__(parent)
        self._setupUI()

    def _setupUI(self):
        self.setupUi(self)
