"""A module to provide the main window for the Renamer GUI."""

# Standard Library
from collections import deque
from enum import IntEnum
from json import dumps, loads
from logging import DEBUG, getLogger
from pathlib import Path

# Third Parties: PIL
from PIL import Image
from PIL.ImageQt import ImageQt
from pillow_heif import register_heif_opener  # pyright: ignore[reportUnknownVariableType, reportMissingTypeStubs]

# PySide
from PySide6.QtCore import QModelIndex, QObject, QProcess, Qt, Signal, Slot
from PySide6.QtGui import QPixmap
from PySide6.QtWidgets import QDialog, QFileDialog, QHeaderView, QListWidgetItem, QWidget

# Autogenerated Code from Qt Creator
from ui.mainWindow import Ui_MainWindow
from ui.mediaFileViewer import Ui_MediaFileViewer

# My own modules
from customLogger import configConsoleHandler, emojiFormatter
from MassRenamer.MassRenamerClasses import (
    IMAGE_EXTENSIONS,
    VIDEO_EXTENSIONS,
    MediaFile,
    findNewNames,
    generateSortedMediaFileList,
    getFilesInFolder,
    inferDateFromNeighbours,
    loadExifToolTagsFromFile,
    storeMediaFileListTags,
)
from models import (
    FileListModel,
    TagListModel,
    ValueListModel,
    fixDateModel,
    showDatelessModel,
    toRenameModel,
)

logger = getLogger(__name__)

# The List of tags to extract with exiftool
TAGS_TO_EXTRACT: list[str] = ["-time:all", "-UserComment", "-Make", "-Model", "-Software", "-GPS:all"]
# Exiftool parameters to extract all the tags we are interested in
# The date formatting is super useful, as it's really smart grabbing offsets, I think
# -G1 group tags
# -a allow duplicate tags
# -s short tag names (no effect with json output but I'll leave it)
# -j output json
# -r recursive folder search
# -d "%Y-%m-%dT%H:%M:%S%:z" output dates in YYYY-MM-DDTHH:MM:SS+/-Offset
EXTRACT_ALL_TAGS_ARGS: list[str] = TAGS_TO_EXTRACT + [
    "-G1",
    "-a",
    "-s",
    "-j",
    "-r",
    "-d",
    "%Y-%m-%dT%H:%M:%S%:z",
    # The only thing missing here is the destination path
]


class CMDTYPE(IntEnum):
    """A silly IntEnum to differentiate the type of command run during the fix dates phase"""

    SAVE_DATE = 0  # this exiftool command is the one that saves the date tags in the file
    RESCAN = 1  # this exiftool command is the one that rescans the tags to grab the new dates


class UpdateProgressSignal(QObject):
    """A Class with a single signal to update the Progress Bar

    This class has a single signal whose only purpose is to be emitted to update the progress of the Progress Bar at the
    bottom of the main window (on tag processing and during the MediaFile list creation).
    This is the (best?) way to do it, as it makes sure that the main thread updates the GUI
    (https://stackoverflow.com/questions/2806552/qprogressbar-not-showing-progress)
    """

    updateProgress = Signal(int)


class Window(QWidget, Ui_MainWindow):
    """The application's main window"""

    def __init__(self):
        super().__init__()
        self._setupUI()

        ### Data Structures
        # When we are fixing dates, this list will hold the date that we select for each file. A dict where
        # the key is the name of the file and the value is the currently selected new date for that file
        self.selectedDates: dict[str, str] = {}

        ### UI stuff
        ## Open file/folder
        self.openFolderBtn.clicked.connect(self.loadFolder)
        self.openJSONBtn.clicked.connect(self.loadExifTagsFromJSON)
        # Media Preview Window
        self.mediaFileViewer = MediaFileViewer(self)
        ## Rename files Tab
        # This list shows the files about to be renamed
        self.toRenameModel = toRenameModel()
        self.toRenamePreviewTable.setModel(self.toRenameModel)
        self.toRenamePreviewTable.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.toRenamePreviewTable.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)

        # Actions
        # Clicking on an item in the Files to Rename list updates the contents of the mini media file viewer
        self.toRenamePreviewTable.clicked.connect(self.updateMediaFileViewer)
        # This button shows the mini media file viewer
        self.mediaFileViewerBtn.clicked.connect(self.showMediaFileViewer)
        # This button refreshes the view (TODO: probably not needed?)
        self.refreshFilesToRenameBtn.clicked.connect(self.loadJSON)
        # This button triggers the renaming of the files
        self.renameBtn.clicked.connect(self.renameFiles)

        ## Fix Dates Tab
        # toFixDates Table: shows the filenames of the files that don't have dates, and the currently selected date for
        # that file, if one has already been chosen
        self.showDatelessModel = showDatelessModel()
        self.toFixDatesTableView.setModel(self.showDatelessModel)
        self.toFixDatesTableView.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.toFixDatesTableView.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.toFixDatesTableView.clicked.connect(self.updateListOfDates)
        # Create a model for the date fixer view, and assign it to the View widget
        self.fixDateModel = fixDateModel()
        self.datesTableView.setModel(self.fixDateModel)
        self.datesTableView.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.datesTableView.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.datesTableView.clicked.connect(self.dateSelected)
        self.setDateBtn.clicked.connect(self.assignNewDates)

        ## The Tag Explorer
        # Models
        self.tagModel = TagListModel(None)
        self.valueModel = ValueListModel(None, "")
        self.fileModel = FileListModel(None, "", "")
        # Set modesl on views
        self.tagView.setModel(self.tagModel)
        self.valueView.setModel(self.valueModel)
        self.fileView.setModel(self.fileModel)
        # Signals
        self.tagView.clicked.connect(self.onTagSelected)
        self.valueView.clicked.connect(self.onValueSelected)
        self.fileView.clicked.connect(self.updateMediaFileViewer)

        ## Progress bar
        # Create an UpdateProgress signal and connect it to the setValue slot of the progress bar
        self.updateProgressSignal = UpdateProgressSignal()
        self.updateProgressSignal.updateProgress.connect(self.progressBar.setValue)

        ### Non-UI Stuff
        # Get root logger and set the emojiFormatter
        rootLogger = getLogger()
        rootLogger.setLevel(DEBUG)
        # Just for some specific situations, add a console logger, but only log warnings and errors (change to errors
        # if found to verbose)
        configConsoleHandler(rootLogger, emojiFormatter())

    def _setupUI(self):
        self.setupUi(self)  # pyright: ignore[reportUnknownMemberType]

    ### Open Files / Folder

    @Slot()
    def loadFolder(self) -> None:
        """Action for the openFolderBtn clicked signal

        Opens a file dialog to allow picking a folder with files to rename. It will grab tags for all procesable files
        recursively and save the tags in a JSON file (as this process can take time for big folders).
        """
        # Let's select a folder and process its files

        # self.toRenameList.clear()  # clear the files to rename list on button click
        self.currJSONTxt.clear()  # clear the any current JSON
        # If the currDirTxt lineEdit has text on it, use it as reference for the file dialog. Otherwise, use home() as
        # starting point
        if self.currDirTxt.text():
            initDir = self.currDirTxt.text()
        else:
            # initDir = str(Path.home())  # default to the user's home
            initDir = r"C:\Users\mundo\OneDrive\Desktop\EXIFPhotoRenamer\FotosTest\A"

        self._selDir = QFileDialog.getExistingDirectory(self, "Choose Folder Containing the Files To Rename", initDir)

        # Get the number of files in the dir
        self.progressBarTxt.setText("Countnig processsable files in the folder...")
        self.repaint()  # need this to force the change in UI before we hit the UI in the event loop
        numFiles = getFilesInFolder(Path(self._selDir))
        if numFiles == 0:
            # Something went wrong with the file processing
            return
        self.progressBar.setFormat("Processed %v / %m...")
        self.progressBar.setRange(0, numFiles)
        self.progressBar.setValue(0)

        self.progressBarTxt.setText("Extracting Tags from Files...")
        self.repaint()
        # Start ExifTool to grab all tags in the folder
        # A QProcess to run the Exiftool CLI and process all tags
        self._exifToolProcess = QProcess()
        self.etExtractedTagsAsJSON: str = ""
        self._exifToolProcess.readyReadStandardOutput.connect(self.handleStdOutTagParser)
        self._exifToolProcess.readyReadStandardError.connect(self.handleStdOutTagParser)
        self._exifToolProcess.finished.connect(self.handleFinishedTagParser)

        # (A bit of a convoluted way to add the dir to a list of args while still keeping the list unmodified)
        self._exifToolProcess.start("exiftool", EXTRACT_ALL_TAGS_ARGS + [self._selDir])
        # From here, we listen to the output and handle it in `handleStdOut()` and check the process state and handle it
        # in `handleState()`

    @Slot()
    def handleStdOutTagParser(self) -> None:
        """Check the standard out for signs of files being processed and update the progress bar"""
        data = self._exifToolProcess.readAllStandardOutput().toStdString()
        for line in data.splitlines():
            if line:
                line.rstrip()
                self.etExtractedTagsAsJSON += line
                if "SourceFile" in line:
                    self.bumpProgressBar()

    @Slot()
    def handleFinishedTagParser(self) -> None:
        """Actions to perform when the tag parser process has finished processing all files"""
        self._exifToolProcess.deleteLater()

        saveFile, _ = QFileDialog.getSaveFileName(
            self,
            "Select A File to Save the Tags",
            self._selDir + "/fileTags.json",  # add fileTags.json to suggest it as predetermined file name
            "JSON Files (*.json)",
        )

        # If the Dialog is cancelled, the file returned is ""
        if saveFile:
            with open(Path(saveFile), "w+") as writeFile:
                writeFile.write(self.etExtractedTagsAsJSON)
            self.progressBarTxt.setText(f"Tags Saved in {saveFile}")
        else:
            self.progressBarTxt.setText("We didn't save the tags :(")

    def bumpProgressBar(self) -> None:
        """Emits a updateProgress signal to indicate the Progress bar of its new value"""
        self.updateProgressSignal.updateProgress.emit(self.progressBar.value() + 1)

    @Slot()
    def loadJSON(self) -> None:
        """Creates a sorted list of MediaFile instances from a list of dictionaries containing EXIFTool Tags

        It also checks for elements without a date and adds them to the Fix Dates Tab.
        """
        ### Get a list of MediaFile from a list of tags and sort it by filename (natural sorting)
        self.progressBarTxt.setText("Building List of MediaFile items...")
        tagsDictList = loadExifToolTagsFromFile(Path(self._jsonFile))
        self.progressBar.setRange(0, len(tagsDictList))
        self.progressBar.setValue(0)
        self.progressBar.setFormat("Processed %v / %m...")

        self.mediaFileList = generateSortedMediaFileList(tagsDictList, self.bumpProgressBar)
        self.progressBarTxt.setText("List of MediaFile Generated")

        ### Update Models
        # Files to rename: check in which ones we could get a new name with the info we have
        findNewNames(self.mediaFileList, Path(self.currDirTxt.text()))
        self.toRenameModel.replaceListOfFiles(self.mediaFileList)

        # Find Dateless, infer their date from neighbours.
        # Build a list of dateless items with their index in the mediaFileListGet, then get their left and right
        # inference and store in the tags section of the mediaFileList using the index
        dateless: list[tuple[int, MediaFile]] = [
            (index, instance) for index, instance in enumerate(self.mediaFileList) if instance.dateTime is None
        ]

        if len(dateless) > 0:
            for datelessItem in dateless:
                inferredDates = inferDateFromNeighbours(datelessItem[0], self.mediaFileList)
                if inferredDates[0]:
                    self.mediaFileList[datelessItem[0]].EXIFTags["Inferred:LeftDate"] = inferredDates[0]
                if inferredDates[1]:
                    self.mediaFileList[datelessItem[0]].EXIFTags["Inferred:RightDate"] = inferredDates[1]

        # Update the files to infer new date model
        self.showDatelessModel.replaceListOfFiles(self.mediaFileList)

        # Load the tags in the tag explorer
        self.tagModel.replaceListOfTags(self.mediaFileList)
        self.valueModel.replaceListOfValues(self.mediaFileList, self.tagModel.tags[0]) if self.tagModel.tags else ""
        self.fileModel.replaceListOfFiles(
            self.mediaFileList, self.tagModel.tags[0], self.valueModel.values[0]
        ) if self.valueModel and self.valueModel.values else ""

    @Slot()
    def loadExifTagsFromJSON(self) -> None:
        """Action for the selection of a JSON file dialog.

        Selects a JSON file with the output of EXIFTool, and creates a sorted list of MediaFileInstances, pointing
        to files that might need their date fixed.
        """
        self.selectedDates = {}

        # If the current directory field has something on it, use it as starting point for looking for a JSON
        if self.currDirTxt.text():
            initDir = self.currDirTxt.text()
        else:
            # initDir = str(Path.home())  # default to the user's home
            initDir = r"C:\Users\mundo\OneDrive\Desktop\EXIFPhotoRenamer\FotosTest\A"
        self._jsonFile, _ = QFileDialog.getOpenFileName(self, "Pick a JSON file with your EXIF tags", initDir, "*.json")
        if self._jsonFile:
            self.currJSONTxt.setText(self._jsonFile)
            # Clear it after the JSON was selected, to avoid ambiguity about what is open
            self.currDirTxt.setText(str(Path(self._jsonFile).parent))
            # Create a list of MediaFile instances
            self.loadJSON()

    ### Rename

    @Slot()
    def renameFiles(self) -> None:
        """Action for the Rename Button

        Proceeds to rename all files that have a new name that is different to their current name
        """
        for mediaFile in self.mediaFileList:
            if mediaFile.newName and mediaFile.fileName != mediaFile.newName:
                if self.dryRunChkBox.checkState() == Qt.CheckState.Checked:
                    logger.info(f"{mediaFile.fileName} -> {mediaFile.newName}")
                    if mediaFile.sidecar:
                        logger.warning(f"{mediaFile.sidecar} -> {mediaFile.newName.with_suffix('.aae')}")
                else:
                    if not mediaFile.newName.parent.is_dir():
                        mediaFile.newName.parent.mkdir(parents=True)
                    mediaFile.fileName.rename(mediaFile.newName)
                    if mediaFile.sidecar:
                        mediaFile.sidecar.rename(mediaFile.newName.with_suffix(".aae"))
                    pass

    ### Media File Viewer

    @Slot()
    def showMediaFileViewer(self) -> None:
        """Shows the MediaFile Viewer"""
        self.mediaFileViewer.show()
        # Reposition Window to the right of the main window on show.
        # X coord is MainWindow's x + MainWindow's width (so both windows match side to side)
        # Y coord is MainWindow's y (so titlebars are aligned in height)
        self.mediaFileViewer.move(self.geometry().x() + self.width(), self.y())

    def _updateMediaFileViewerFromInstance(self, mediaFile: MediaFile) -> None:
        self.mediaFileViewer.filePathTxt.setText(str(mediaFile.fileName))
        self.mediaFileViewer.dateTimeTxt.setText(mediaFile.dateTime)
        self.mediaFileViewer.sidecarTxt.setText(str(mediaFile.sidecar))
        self.mediaFileViewer.sourceTxt.setText(mediaFile.source)
        self.mediaFileViewer.tagsTxt.setPlainText(dumps(mediaFile.EXIFTags, indent=2))
        ext = mediaFile.fileName.suffix
        pixMap: QPixmap | None = None
        if ext.lower() in [".jpg", ".jpeg", ".png", ".tiff", ".gif"]:
            pixMap = QPixmap(mediaFile.fileName)
        elif ext.lower() in [".heif", ".heic"]:
            register_heif_opener()
            image = Image.open(mediaFile.fileName)
            qim = ImageQt(image)
            pixMap = QPixmap.fromImage(qim)

        if pixMap:
            # Set the pixMap in the label, and scale while keepint the AspectRatio
            self.mediaFileViewer.imageLbl.setPixmap(
                pixMap.scaled(self.mediaFileViewer.imageLbl.size(), Qt.AspectRatioMode.KeepAspectRatio)
            )

    @Slot(QListWidgetItem)
    def updateMediaFileViewer(self, current: QModelIndex) -> None:
        """Updates the info on the MediaFile viewer dialog with the item  of the table we just clikced on

        Args:
            current (QModelIndex): the item we clicked on
        """
        # Get the name of the item clicked. If we clicked on the filename, the value is in current.data(), but if we
        # clicked in the rename file, the we would get that. So instead, get the row, and get whatever is there at
        # column 0 (filename)
        row = current.row()  # get row clicked
        currFile = str(current.sibling(row, 0).data())  # get item in col 0 of that row, file Name
        instance: MediaFile | None = next(
            filter(lambda instance: instance.fileName == Path(currFile), self.mediaFileList), None
        )  # get the MediaFile that has currFile as its fileName

        # If found, update the panel
        if instance:
            self._updateMediaFileViewerFromInstance(instance)

    ### Fix Dates

    @Slot()
    def updateListOfDates(self) -> None:
        """Action triggered when a new date is chosen from the dates available for an item without date.

        When we select an item from the Files without a clear date, update the MediaFile viewer pane to get some
        context and then show its date tags so one can be selected
        """
        # To get the selected filename, get the index of the currently selected cell ...
        index = self.toFixDatesTableView.selectionModel().currentIndex()
        # and grab whatever is in column 0
        currFileName = str(index.sibling(index.row(), 0).data())

        # Find an instance of MediaFile that has currFileName as its filename
        instance: MediaFile | None = next(
            filter(lambda instance: instance.fileName == Path(currFileName), self.mediaFileList), None
        )
        if instance:
            # If the selected item is in the list (it should!) then update the mediaViewer pane
            self._updateMediaFileViewerFromInstance(instance)
            # And update the fix dates model to show its date tags
            self.fixDateModel.replaceListOfTags(instance)
            # Clear the selection as it might be out of bounds in the new list
            self.datesTableView.clearSelection()
            # And finally, if a date has been selected already, show it
            if str(instance.fileName) in self.selectedDates.keys():
                self.dateChosenTxt.setText(self.selectedDates[str(instance.fileName)])

    @Slot()
    def dateSelected(self) -> None:
        """Action to perform when a date of the available dates to fix a dateless item has been  selected"""
        index = self.datesTableView.selectionModel().currentIndex()
        # Get the value of the time column, no matter which one of the two cells was clicked
        valueStr = str(index.sibling(index.row(), 1).data())
        self.dateChosenTxt.setText(valueStr)
        # If the key doesn't exist, it will add it, and if it does, it will update it
        # To get the selected filename, get the index of the currently selected cell in the toFixDatesTableView
        index = self.toFixDatesTableView.selectionModel().currentIndex()
        # and grab whatever is in column 0
        currFileName = str(index.sibling(index.row(), 0).data())
        self.selectedDates[currFileName] = valueStr

        # Update the Model of the dateless files to show the selected date together with its corresponding filename
        # We can get the index of the list from row of the index of the currently selected cell
        row = self.toFixDatesTableView.selectionModel().currentIndex().row()
        self.showDatelessModel.datelessItemsList[row] = (currFileName, valueStr)
        self.showDatelessModel.layoutChanged.emit()

    @staticmethod
    def saveNewDateTags(extension: str, date: str) -> list[str]:
        """Generates the arguments to call exiftool to store a new creation date

        Args:
            extension (str): _description_
            date (str): _description_

        Raises:
            ValueError: _description_

        Returns:
            list[str]: _description_
        """
        generalArgs = [
            "-P",
            "-overwrite_original",
            "-d",
            '"%Y-%m-%dT%H:%M:%S%:z"',
        ]

        saveDateArgs = [
            f'-DateTimeOriginal="{date}"',
            f'-CreateDate="{date}"',
            f'-OffsetTimeOriginal="{date[-6:]}"',
            f'-OffsetTimeDigitized="{date[-6:]}"',
        ]

        videoTags = [
            f'-TrackCreateDate="{date}"',
            f'-TrackModifyDate="{date}"',
            f'-MediaCreateDate="{date}"',
            f'-MediaModifyDate="{date}"',
        ]

        if extension.lower() in IMAGE_EXTENSIONS:
            return saveDateArgs + generalArgs
        elif extension.lower() in VIDEO_EXTENSIONS:
            return saveDateArgs + videoTags + generalArgs
        else:
            raise ValueError(f"{extension} is not in the lists!")

    @Slot()
    def assignNewDates(self) -> None:
        """Assigns the currently selected dates on their dateless items"""
        ### Strategy
        # We have a list of dateless items. Some of them now have a new date for them.
        # The idea is to go file by file, inject the new date, re-read the tags, update the tags in its MediaFile
        # instance. Once all the files have been processed, we can save the state, as that's the best

        # Instead of running the process, wait for it to finish and run the next one, we are going to build a deque with
        # all the commands that we would have to run, and then run the first and pop the next on onFinish().
        # I'll add an identifier to each deque element, so we can point each QProcess to the the correct slots.
        self._cmdDeque: deque[tuple[CMDTYPE, list[str]]] = deque()
        for item in self.showDatelessModel.datelessItemsList:
            # item is a tuple with a path as a string and the date chosen for it
            (fileName, newDate) = item
            # If the item has a new date
            if newDate:
                # These are the arguments to save the date

                saveNewDateArgs = self.saveNewDateTags(Path(fileName).suffix, newDate)
                self._cmdDeque.append((CMDTYPE.SAVE_DATE, ["exiftool"] + saveNewDateArgs + [fileName]))
                # As we fix the dates, we can build a list of rescan commands to run. See step 2 below
                self._cmdDeque.append((CMDTYPE.RESCAN, ["exiftool"] + EXTRACT_ALL_TAGS_ARGS + [fileName]))

        # First, we store new dates on those dateless items were a new date has been selected.
        # Setup the progress bar
        numFiles = len(self._cmdDeque) // 2
        # Get the number of files in the dir
        self.progressBarTxt.setText("Storing new dates in items...")
        self.repaint()  # need this to force the change in UI before we hit the UI in the event loop
        self.progressBar.setRange(0, numFiles)
        self.progressBar.setValue(0)

        if self._cmdDeque:  # if deque is not empty
            self.runNextCmd()
            # From here, we listen to the output and handle it in `handleStdOutReScan()` and check the process state and
            # handle it in `handleFinishedReScan()`

    def runNextCmd(self) -> None:
        """Runs the next command in the command deque

        Saving new dats it's a bit clunky, as we save a date and then rescan that file to get its new tags, and the
        number of files is variable, so we have built a deque of commands and we pop them one by one. This function
        runs commands as long as there are commands remaining and then also handles the action to run when we finish.
        """
        if self._cmdDeque:
            (cmdType, nextCmd) = self._cmdDeque.popleft()
            self._exifToolProcess = QProcess(self)
            if cmdType == CMDTYPE.SAVE_DATE:
                self._exifToolProcess.readyReadStandardOutput.connect(self.handleStdOutSaveDate)
                self._exifToolProcess.readyReadStandardError.connect(self.handleStdOutSaveDate)
                self._exifToolProcess.finished.connect(self.handleFinishedSaveDate)
                self._exifToolProcess.errorOccurred.connect(self.handleError)
                self._exifToolProcess.setProgram(nextCmd[0])
                self._exifToolProcess.setArguments(nextCmd[1:])
                self.etReScanOutput: str = ""
                logger.debug(f"Running {' '.join(nextCmd)}")
                self._exifToolProcess.start()
            elif cmdType == CMDTYPE.RESCAN:
                self._exifToolProcess.readyReadStandardOutput.connect(self.handleStdOutReScan)
                self._exifToolProcess.readyReadStandardError.connect(self.handleStdOutReScan)
                self._exifToolProcess.finished.connect(self.handleFinishedReScan)
                self._exifToolProcess.errorOccurred.connect(self.handleError)
                self._exifToolProcess.setProgram(nextCmd[0])
                self._exifToolProcess.setArguments(nextCmd[1:])
                self.etReScanOutput: str = ""
                logger.debug(f"Running {' '.join(nextCmd)}")
                self._exifToolProcess.start()
        else:
            # That was the last command, save the tags and reload them
            self.progressBarTxt.setText(
                f"Saved new dates in {self.progressBar.value()} {'files' if self.progressBar.value() > 1 else 'file'}"
            )
            # As we have modified the mediaFileList, the easiest way to do now to update the state is save it as the
            # json file we used to open the list and reload it
            if Path(self._jsonFile).is_file():
                storeMediaFileListTags(Path(self._jsonFile), self.mediaFileList)
                # TODO:
            # else:
            #    open dialog?
            # make sure the filename is stored in _jsonFile

            # Reload the new JSON
            self.loadJSON()

    @Slot()
    def handleStdOutSaveDate(self) -> None:
        """Action for the standard out from the save date commands

        Doesn't really do anything...
        """
        self.etReScanOutput = self._exifToolProcess.readAllStandardOutput().toStdString()

    @Slot()
    def handleFinishedSaveDate(self) -> None:
        """Action for the end of each of the save date process"""
        logger.debug(f"Saved dates in file {self._exifToolProcess.arguments()[-1]}")
        self._exifToolProcess.deleteLater()
        self.runNextCmd()

    @Slot()
    def handleStdOutReScan(self) -> None:
        """Handles the standard out of the rescan commands

        Check the standard out for signs of files being processed, gets its tags, updates the MediaFile list with the
        new tags and and updates the progress bar
        """
        self.etReScanOutput = self._exifToolProcess.readAllStandardOutput().toStdString()
        # The tags are returned as a json string, loads it, place them in the metadata section of the relevant
        # item of the mediaFileList. ExifTool returns the tags as a list of dicts, as we are only dealing with one
        # file, take the first element of the list
        newTags: dict[str, str] = loads(self.etReScanOutput)[0]
        # Get the filename, which is the
        fileName = self._exifToolProcess.arguments()[-1]
        idx = self.mediaFileList.index(
            next(filter(lambda instance: instance.fileName == Path(fileName), self.mediaFileList))
        )
        self.mediaFileList[idx].EXIFTags = newTags

    @Slot()
    def handleFinishedReScan(self) -> None:
        """Action for the end of a rescan command

        Cleanup and bump the progress bar
        """
        logger.debug(f"Rescanned {self._exifToolProcess.arguments()[-1]}")
        self._exifToolProcess.deleteLater()
        self.runNextCmd()
        # Because we have saved the date and rescanned, we can update the progress bar now
        self.bumpProgressBar()

    @Slot()
    def handleError(self, error: QProcess.ProcessError) -> None:
        """Handles errors on the save new date/rescan tags processes"""
        logger.info(error)

    ### Tag Explorer

    @Slot()
    def onTagSelected(self, index: QModelIndex):
        """Action when a new tag is selected in the Tag List

        Replaces the values and files models to show the values for that tag and the files that have the first value
        """
        tag = self.tagModel.data(index, Qt.ItemDataRole.DisplayRole)
        if tag and isinstance(tag, str):
            self.valueModel.replaceListOfValues(self.mediaFileList, tag)
            # Reset file view
            if self.valueModel.values:
                self.fileModel.replaceListOfFiles(self.mediaFileList, tag, self.valueModel.values[0])
        # else:
        #     self.fileView.setModel(FileListModel([], "", ""))

    @Slot()
    def onValueSelected(self, index: QModelIndex):
        """Action when a value for a tag is selected

        Update the files model to show files that have that value for the selected tag
        """
        tag_index = self.tagView.currentIndex()
        tag = self.tagModel.data(tag_index, Qt.ItemDataRole.DisplayRole)
        value = self.valueModel.data(index, Qt.ItemDataRole.DisplayRole)
        if tag and value and isinstance(tag, str):
            self.fileModel.replaceListOfFiles(self.mediaFileList, tag, value)


class MediaFileViewer(QDialog, Ui_MediaFileViewer):
    """A little side window that shows info from the file selected

    It displays some of the metadata from the MediaFile instance, its Exif tags and a small preview of the image.
    """

    def __init__(self, parent: None | QWidget = None):
        super().__init__(parent)
        self._setupUI()

    def _setupUI(self):
        self.setupUi(self)  # pyright: ignore[reportUnknownMemberType]
